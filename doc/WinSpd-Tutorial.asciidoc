= Tutorial: creating a simple file system
:toc: preamble
:toc-title:
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]

In this tutorial we describe the process of creating a simple user mode storage device using WinSpd. The storage device we will create is called "rawdisk" and stores disk data as raw data in a regular file.

== Prerequisites

This tutorial assumes that you have WinSpd and Visual Studio 2015 installed. The WinSpd installer can be downloaded from the WinSpd GitHub repository: https://github.com/billziss-gh/winspd. The Microsoft Visual Studio Community 2015 can be downloaded for free from Microsoft's web site.

When installing WinSpd make sure to choose "Developer" to ensure that all necessary header and library files are included in the installation.

image::WinSpd-Tutorial/Installer.png[WinSpd Installer]

With those prerequisites out of the way we are now ready to start creating our first storage unit.

NOTE: The storage device that we will create is included as a sample with the WinSpd installer. Look in the `samples\rawdisk` directory.

== Create the project skeleton

We start by creating the Visual Studio project. Choose "Win32 Console Application" and select empty project.

image::WinSpd-Tutorial/NewProject.png[Visual Studio New Project]

NOTE: A user mode storage device services requests from the operating system. Therefore it becomes an important system component and must service requests timely. In general it should be a console mode application, not block for user input after it has been initialized, and not expose a GUI. This also allows the user mode storage device to be converted into a Windows service easily or to be controlled by the WinSpd.Launcher service.

We add an empty file named `rawdisk.c` in the project and add the following skeleton code.

.`*rawdisk.c*`
[source,c]
----
#include <winspd/winspd.h>                                              // <1>

int wmain(int argc, wchar_t **argv)
{
    return 0;
}
----
<1> Include WinFsp header file.

We must also set up the locations where Visual Studio can find the WinSpd headers and libraries. The following project settings must be made:

- C/C++ > General > Additional Include Directories: `$(MSBuildProgramFiles32)\WinSpd\inc`
- Linker > Input > Additional Dependencies: `$(MSBuildProgramFiles32)\WinSpd\lib\winspd-$(PlatformTarget).lib`

NOTE: These settings assume that WinSpd has been installed in the default location under "Program Files".

We now have a complete project skeleton and can proceed with implementing our storage device!

== Top level code

The top level code of the rawdisk storage device starts at `wmain`, performs command line handling, sets up a file to act as backing storage, creates a storage unit which is registered with the OS and starts servicing requests for it.

We first consider command line handling. We want the rawdisk storage device to be used as follows:

.`*usage*`
----
usage: rawdisk OPTIONS

options:
    -f RawDiskFile                      Storage unit data file
    -c BlockCount                       Storage unit size in blocks
    -l BlockLength                      Storage unit block length
    -i ProductId                        1-16 chars
    -r ProductRevision                  1-4 chars
    -W 0|1                              Disable/enable writes (deflt: enable)
    -C 0|1                              Disable/enable cache (deflt: enable)
    -U 0|1                              Disable/enable unmap (deflt: enable)
    -d -1                               Debug flags
    -D DebugLogFile                     Debug log file; - for stderr
    -p \\.\pipe\PipeName                Listen on pipe; omit to use driver
----

The full code to handle these command line parameters is straight forward and is omitted for brevity. It can be found in the `rawdisk.c` sample file that ships with the WinSpd installer. The code sets a number of variables that are used to configure each run of the passthrough file system.

.`*wmain excerpt*`
[source,c]
----
    PWSTR RawDiskFile = 0;
    ULONG BlockCount = 1024 * 1024;
    ULONG BlockLength = 512;
    PWSTR ProductId = L"RawDisk";
    PWSTR ProductRevision = L"1.0";
    ULONG WriteAllowed = 1;
    ULONG CacheSupported = 1;
    ULONG UnmapSupported = 1;
    ULONG DebugFlags = 0;
    PWSTR DebugLogFile = 0;
    PWSTR PipeName = 0;
----

The variable `DebugLogFile` is used to control the WinSpd debug logging mechanism. This mechanism can send messages to the debugger for display or log them into a file. The behavior is controlled by a call to `SpdDebugLogSetHandle`: if this call is not made any debug log messages will be sent to the debugger; if this call is made debug log messages will be logged into the specified file handle.

.`*wmain excerpt*`
[source,c]
----
    if (0 != DebugLogFile)
    {
        if (L'-' == DebugLogFile[0] && L'\0' == DebugLogFile[1])
            DebugLogHandle = GetStdHandle(STD_ERROR_HANDLE);
        else
            DebugLogHandle = CreateFileW(
                DebugLogFile,
                FILE_APPEND_DATA,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                0,
                OPEN_ALWAYS,
                FILE_ATTRIBUTE_NORMAL,
                0);
        if (INVALID_HANDLE_VALUE == DebugLogHandle)
            fail(GetLastError(), L"error: cannot open debug log file");

        SpdDebugLogSetHandle(DebugLogHandle);
    }
----

The remaining variables are used to set up a file to act as backing storage and create and start a storage unit.

.`*wmain excerpt*`
[source,c]
----
    Error = RawDiskCreate(RawDiskFile,
        BlockCount, BlockLength,
        ProductId, ProductRevision,
        !WriteAllowed,
        !!CacheSupported,
        !!UnmapSupported,
        PipeName,
        &RawDisk);                                                      // <1>
    if (0 != Error)
        fail(Error, L"error: cannot create RawDisk: error %lu", Error);
    Error = SpdStorageUnitStartDispatcher(
        RawDiskStorageUnit(RawDisk), 2);                                // <2>
    if (0 != Error)
        fail(Error, L"error: cannot start RawDisk: error %lu", Error);

    ...

    SpdGuardSet(&ConsoleCtrlGuard, RawDiskStorageUnit(RawDisk));        // <3>
    SetConsoleCtrlHandler(ConsoleCtrlHandler, TRUE);                    // <4>
    SpdStorageUnitWaitDispatcher(RawDiskStorageUnit(RawDisk));          // <5>
    SpdGuardSet(&ConsoleCtrlGuard, 0);                                  // <6>

    RawDiskDelete(RawDisk);                                             // <7>
----
<1> Create the rawdisk storage unit.
<2> Start the storage unit dispatcher. At this point the storage unit starts receiving storage requests (if any).
<3> Set a "guarded" pointer to the storage unit so that it can be shutdown in a thread-safe manner by the process console control handler.
<4> Set up a console control handler for the process.
<5> Wait until the storage unit (and its dispatcher) is shutdown.
<6> Reset the "guarded" pointer.
<7> Delete the rawdisk storage unit.

We now consider the code for `RawDiskCreate`, `RawDiskDelete` and `ConsoleCtrlHandler`:

.`*RawDiskCreate*`
[source,c]
----
typedef struct _RAWDISK
{
    SPD_STORAGE_UNIT *StorageUnit;
    UINT64 BlockCount;
    UINT32 BlockLength;
    HANDLE Handle;
    HANDLE Mapping;
    PVOID Pointer;
    BOOLEAN Sparse;
} RAWDISK;

...

static SPD_STORAGE_UNIT_INTERFACE RawDiskInterface =
{
    0,
};

DWORD RawDiskCreate(PWSTR RawDiskFile,
    UINT64 BlockCount, UINT32 BlockLength,
    PWSTR ProductId, PWSTR ProductRevision,
    BOOLEAN WriteProtected,
    BOOLEAN CacheSupported,
    BOOLEAN UnmapSupported,
    PWSTR PipeName,
    RAWDISK **PRawDisk)
{
    RAWDISK *RawDisk = 0;
    HANDLE Handle = INVALID_HANDLE_VALUE;
    HANDLE Mapping = 0;
    PVOID Pointer = 0;
    FILE_SET_SPARSE_BUFFER Sparse;
    DWORD BytesTransferred;
    LARGE_INTEGER FileSize;
    BOOLEAN ZeroSize;
    SPD_PARTITION Partition;
    SPD_STORAGE_UNIT_PARAMS StorageUnitParams;
    SPD_STORAGE_UNIT *StorageUnit = 0;
    DWORD Error;

    *PRawDisk = 0;

    memset(&StorageUnitParams, 0, sizeof StorageUnitParams);            // <1>
    UuidCreate(&StorageUnitParams.Guid);                                // <1>
    StorageUnitParams.BlockCount = BlockCount;                          // <1>
    StorageUnitParams.BlockLength = BlockLength;                        // <1>
    StorageUnitParams.MaxTransferLength = 64 * 1024;                    // <1>
    if (0 == WideCharToMultiByte(CP_UTF8, 0,                            // <1>
        ProductId, lstrlenW(ProductId),                                 // <1>
        StorageUnitParams.ProductId,                                    // <1>
        sizeof StorageUnitParams.ProductId,                             // <1>
        0, 0))                                                          // <1>
    {                                                                   // <1>
        Error = ERROR_INVALID_PARAMETER;                                // <1>
        goto exit;                                                      // <1>
    }                                                                   // <1>
    if (0 == WideCharToMultiByte(CP_UTF8, 0,                            // <1>
        ProductRevision, lstrlenW(ProductRevision),                     // <1>
        StorageUnitParams.ProductRevisionLevel,                         // <1>
        sizeof StorageUnitParams.ProductRevisionLevel,                  // <1>
        0, 0))                                                          // <1>
    {                                                                   // <1>
        Error = ERROR_INVALID_PARAMETER;                                // <1>
        goto exit;                                                      // <1>
    }                                                                   // <1>
    StorageUnitParams.WriteProtected = WriteProtected;                  // <1>
    StorageUnitParams.CacheSupported = CacheSupported;                  // <1>
    StorageUnitParams.UnmapSupported = UnmapSupported;                  // <1>

    RawDisk = malloc(sizeof *RawDisk);
    if (0 == RawDisk)
    {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    Handle = CreateFileW(RawDiskFile,
        GENERIC_READ | GENERIC_WRITE, 0, 0,
        OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);                         // <2>
    if (INVALID_HANDLE_VALUE == Handle)
    {
        Error = GetLastError();
        goto exit;
    }

    Sparse.SetSparse = TRUE;
    Sparse.SetSparse = DeviceIoControl(Handle,
        FSCTL_SET_SPARSE, &Sparse, sizeof Sparse, 0, 0,
        &BytesTransferred, 0);                                          // <3>

    if (!GetFileSizeEx(Handle, &FileSize))
    {
        Error = GetLastError();
        goto exit;
    }

    ZeroSize = 0 == FileSize.QuadPart;
    if (ZeroSize)
        FileSize.QuadPart = BlockCount * BlockLength;
    if (0 == FileSize.QuadPart ||
        BlockCount * BlockLength != FileSize.QuadPart)                  // <4>
    {
        Error = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    if (!SetFilePointerEx(Handle, FileSize, 0, FILE_BEGIN) ||
        !SetEndOfFile(Handle))                                          // <5>
    {
        Error = GetLastError();
        goto exit;
    }

    Mapping = CreateFileMappingW(Handle, 0, PAGE_READWRITE, 0, 0, 0);   // <6>
    if (0 == Mapping)
    {
        Error = GetLastError();
        goto exit;
    }

    Pointer = MapViewOfFile(Mapping, FILE_MAP_ALL_ACCESS, 0, 0, 0);     // <6>
    if (0 == Pointer)
    {
        Error = GetLastError();
        goto exit;
    }

    if (ZeroSize)
    {
        memset(&Partition, 0, sizeof Partition);
        Partition.Type = 7;
        Partition.BlockAddress =
            4096 >= BlockLength ? 4096 / BlockLength : 1;
        Partition.BlockCount = BlockCount - Partition.BlockAddress;
        if (ERROR_SUCCESS ==
            SpdDefinePartitionTable(&Partition, 1, Pointer))            // <7>
        {
            FlushViewOfFile(Pointer, 0);
            FlushFileBuffers(Handle);
        }
    }

    Error = SpdStorageUnitCreate(PipeName,
        &StorageUnitParams, &RawDiskInterface, &StorageUnit);           // <8>
    if (ERROR_SUCCESS != Error)
        goto exit;

    memset(RawDisk, 0, sizeof *RawDisk);
    RawDisk->StorageUnit = StorageUnit;
    RawDisk->BlockCount = BlockCount;
    RawDisk->BlockLength = BlockLength;
    RawDisk->Handle = Handle;
    RawDisk->Mapping = Mapping;
    RawDisk->Pointer = Pointer;
    RawDisk->Sparse = Sparse.SetSparse;
    StorageUnit->UserContext = RawDisk;                                 // <9>

    *PRawDisk = RawDisk;

    Error = ERROR_SUCCESS;

exit:
    if (ERROR_SUCCESS != Error)
    {
        if (0 != StorageUnit)
            SpdStorageUnitDelete(StorageUnit);

        if (0 != Pointer)
            UnmapViewOfFile(Pointer);

        if (0 != Mapping)
            CloseHandle(Mapping);

        if (INVALID_HANDLE_VALUE != Handle)
            CloseHandle(Handle);

        free(RawDisk);
    }

    return Error;
}
----
<1> Initialize the `StorageUnitParams`. The `Guid` field should in general be persisted with the storage unit's backing storage, although this rule is not followed by the current version of the rawdisk storage device.
<2> Create or open the file that will act as backing storage for our storage unit.
<3> Attempt to set the file as sparse if the underlying file system supports it.
<4> Double-check that the file size matches our expectation based on the storage unit geometry.
<5> Set the file size to the appropriate value for the storage unit geometry. Note that if the file was successfuly set as sparse it should not occupy much actual space in the underlying file system.
<6> Map the file in memory.
<7> If the file was empty when it was first created we add a default partition that encompasses the whole storage unit.
<8> Create the WinSpd `SPD_STORAGE_UNIT` object. This includes associated kernel objects.
<9> Associate our private `RAWDISK` data structure with the WinSpd `SPD_STORAGE_UNIT` object.

.`*RawDiskDelete*`
[source,c]
----
VOID RawDiskDelete(RAWDISK *RawDisk)
{
    SpdStorageUnitDelete(RawDisk->StorageUnit);                         // <1>

    FlushViewOfFile(RawDisk->Pointer, 0);                               // <2>
    FlushFileBuffers(RawDisk->Handle);                                  // <2>
    UnmapViewOfFile(RawDisk->Pointer);                                  // <2>
    CloseHandle(RawDisk->Mapping);                                      // <2>
    CloseHandle(RawDisk->Handle);                                       // <2>

    free(RawDisk);
}
----
<1> Delete the WinSpd `SPD_STORAGE_UNIT` object.
<2> Flush and unmap the backing storage file.

.`*ConsoleCtrlHandler*`
[source,c]
----
static SPD_GUARD ConsoleCtrlGuard = SPD_GUARD_INIT;

static BOOL WINAPI ConsoleCtrlHandler(DWORD CtrlType)
{
    SpdGuardExecute(&ConsoleCtrlGuard, SpdStorageUnitShutdown);         // <1>
    return TRUE;
}
----
<1> Shutdown the storage unit in a thread-safe manner.

=== Test run

We can now run the program from Visual Studio or the command line. The program starts and services storage requests from the operating system. However because we have not yet implemented any storage request handlers all requests will be failed. This is demonstrated by the `diskpart` session below. Press Ctrl-C to stop the storage device.

image::WinSpd-Tutorial/FirstRun.png[First run]

NOTE: Pressing Ctrl-C orderly stops the storage device (by calling `ConsoleCtrlHandler`). It is however possible to forcibly stop a storage device, e.g. by killing the process in the debugger. This is fine with WinSpd as *all associated resources will be automatically cleaned up*. This includes resources that WinSpd knows about such as associated kernel objects and memory, etc. It does not include resources that it has no knowledge about such as temporary files, network registrations, etc.

== Storage unit operations

We now start implementing the actual storage unit operations. These operations are the ones found in `SPD_STORAGE_UNIT_INTERFACE`.

.`*Storage unit operations stubs*`
[source,c]
----
static BOOLEAN Read(SPD_STORAGE_UNIT *StorageUnit,
    PVOID Buffer, UINT64 BlockAddress, UINT32 BlockCount, BOOLEAN FlushFlag,
    SPD_STORAGE_UNIT_STATUS *Status)
{
    return TRUE;
}

static BOOLEAN Write(SPD_STORAGE_UNIT *StorageUnit,
    PVOID Buffer, UINT64 BlockAddress, UINT32 BlockCount, BOOLEAN FlushFlag,
    SPD_STORAGE_UNIT_STATUS *Status)
{
    return TRUE;
}

static BOOLEAN Flush(SPD_STORAGE_UNIT *StorageUnit,
    UINT64 BlockAddress, UINT32 BlockCount,
    SPD_STORAGE_UNIT_STATUS *Status)
{
    return TRUE;
}

static BOOLEAN Unmap(SPD_STORAGE_UNIT *StorageUnit,
    SPD_UNMAP_DESCRIPTOR Descriptors[], UINT32 Count,
    SPD_STORAGE_UNIT_STATUS *Status)
{
    return TRUE;
}

static SPD_STORAGE_UNIT_INTERFACE RawDiskInterface =
{
    Read,
    Write,
    Flush,
    Unmap,
};
----

=== Read / Write

At a minimum a storage unit must implement `Read` and `Write`, unless the storage unit is write-protected (read-only) in which case it may only implement `Read`.

`Read` is used to read block data from the storage unit.

.`*Read*`
[source,c]
----
static BOOLEAN Read(SPD_STORAGE_UNIT *StorageUnit,
    PVOID Buffer, UINT64 BlockAddress, UINT32 BlockCount, BOOLEAN FlushFlag,
    SPD_STORAGE_UNIT_STATUS *Status)
{
    WARNONCE(StorageUnit->StorageUnitParams.CacheSupported || FlushFlag);

    if (FlushFlag)                                                      // <1>
    {
        FlushInternal(StorageUnit, BlockAddress, BlockCount, Status);
        if (SCSISTAT_GOOD != Status->ScsiStatus)
            return TRUE;
    }

    RAWDISK *RawDisk = StorageUnit->UserContext;
    PVOID FileBuffer =
        (PUINT8)RawDisk->Pointer + BlockAddress * RawDisk->BlockLength; // <2>

    CopyBuffer(StorageUnit,
        Buffer, FileBuffer, BlockCount * RawDisk->BlockLength,
        SCSI_ADSENSE_UNRECOVERED_ERROR,
        Status);                                                        // <3>

    return TRUE;
}
----
<1> If the `FlushFlag` is set then the storage unit cache must be flushed prior to reading.
<2> Compute a pointer inside the backing storage file mapping based on arguments and our storage unit geometry.
<3> Copy data from the file mapping into the supplied `Buffer`.

`Write` is used to write block data to the storage unit.

.`*Write*`
[source,c]
----
static BOOLEAN Write(SPD_STORAGE_UNIT *StorageUnit,
    PVOID Buffer, UINT64 BlockAddress, UINT32 BlockCount, BOOLEAN FlushFlag,
    SPD_STORAGE_UNIT_STATUS *Status)
{
    WARNONCE(!StorageUnit->StorageUnitParams.WriteProtected);
    WARNONCE(StorageUnit->StorageUnitParams.CacheSupported || FlushFlag);

    RAWDISK *RawDisk = StorageUnit->UserContext;
    PVOID FileBuffer =
        (PUINT8)RawDisk->Pointer + BlockAddress * RawDisk->BlockLength; // <1>

    CopyBuffer(StorageUnit,
        FileBuffer, Buffer, BlockCount * RawDisk->BlockLength,
        SCSI_ADSENSE_WRITE_ERROR,
        Status);                                                        // <2>

    if (SCSISTAT_GOOD == Status->ScsiStatus && FlushFlag)               // <3>
        FlushInternal(StorageUnit, BlockAddress, BlockCount, Status);

    return TRUE;
}
----
<1> Compute a pointer inside the backing storage file mapping based on arguments and our storage unit geometry.
<3> Copy data from the supplied `Buffer` into the file mapping.
<3> If the `FlushFlag` is set then the storage unit cache must be flushed after writing.

=== Flush

A storage unit that has its own cache must implement `Flush`.

.`*Flush*`
[source,c]
----
static BOOLEAN Flush(SPD_STORAGE_UNIT *StorageUnit,
    UINT64 BlockAddress, UINT32 BlockCount,
    SPD_STORAGE_UNIT_STATUS *Status)
{
    WARNONCE(!StorageUnit->StorageUnitParams.WriteProtected);
    WARNONCE(StorageUnit->StorageUnitParams.CacheSupported);

    return FlushInternal(StorageUnit, BlockAddress, BlockCount, Status);
}
----

=== Unmap

A storage unit may implement `Unmap` so that it can be informed by the OS when a block is no longer needed.

.`*Unmap*`
[source,c]
----
static BOOLEAN Unmap(SPD_STORAGE_UNIT *StorageUnit,
    SPD_UNMAP_DESCRIPTOR Descriptors[], UINT32 Count,
    SPD_STORAGE_UNIT_STATUS *Status)
{
    WARNONCE(!StorageUnit->StorageUnitParams.WriteProtected);
    WARNONCE(StorageUnit->StorageUnitParams.UnmapSupported);

    RAWDISK *RawDisk = StorageUnit->UserContext;
    FILE_ZERO_DATA_INFORMATION Zero;
    DWORD BytesTransferred;
    PVOID FileBuffer;

    for (UINT32 I = 0; Count > I; I++)
    {
        BOOLEAN SetZero = FALSE;

        if (RawDisk->Sparse)
        {
            Zero.FileOffset.QuadPart = Descriptors[I].BlockAddress * RawDisk->BlockLength;
            Zero.BeyondFinalZero.QuadPart = (Descriptors[I].BlockAddress + Descriptors[I].BlockCount) *
                RawDisk->BlockLength;
            SetZero = DeviceIoControl(RawDisk->Handle,
                FSCTL_SET_ZERO_DATA, &Zero, sizeof Zero, 0, 0,
                &BytesTransferred, 0);                                  // <1>
        }

        if (!SetZero)
        {
            FileBuffer = (PUINT8)RawDisk->Pointer + Descriptors[I].BlockAddress * RawDisk->BlockLength;

            CopyBuffer(StorageUnit,
                FileBuffer, 0, Descriptors[I].BlockCount * RawDisk->BlockLength,
                SCSI_ADSENSE_NO_SENSE,
                0);                                                     // <2>
        }
    }

    return TRUE;
}
----
<1> Use `FSCTL_SET_ZERO_DATA` to zero the relevant backing storage file range. File systems that support sparse files may "deallocate disk space" in the file in this case.
<2> If the file is not sparse of the `FSCTL_SET_ZERO_DATA` method failed, zero the relevant backing storage file range. This is not strictly required by Windows, but it is required by the WinSpd test suites.

=== Helper functions

A number of functions were used in the implementation of the storage unit operations that have not been presented so far. We include them below.

`CopyBuffer` is used to copy data from the backing storage file mapping to the OS supplied buffers or vice-versa. This is a simple memory copy operation, except that it must also be able to deal with the `EXCEPTION_IN_PAGE_ERROR` exception code, which means that there was an I/O error with the file mapping.

.`*CopyBuffer and ExceptionFilter*`
[source,c]
----
static inline BOOLEAN ExceptionFilter(ULONG Code, PEXCEPTION_POINTERS Pointers,
    PUINT_PTR PDataAddress)
{
    if (EXCEPTION_IN_PAGE_ERROR != Code)
        return EXCEPTION_CONTINUE_SEARCH;

    *PDataAddress = 2 <= Pointers->ExceptionRecord->NumberParameters ?
        Pointers->ExceptionRecord->ExceptionInformation[1] : 0;
    return EXCEPTION_EXECUTE_HANDLER;
}

static VOID CopyBuffer(SPD_STORAGE_UNIT *StorageUnit,
    PVOID Dst, PVOID Src, ULONG Length, UINT8 ASC,
    SPD_STORAGE_UNIT_STATUS *Status)
{
    RAWDISK *RawDisk = StorageUnit->UserContext;
    UINT_PTR ExceptionDataAddress;
    UINT64 Information, *PInformation;

    __try
    {
        if (0 != Src)
            memcpy(Dst, Src, Length);                                   // <1>
        else
            memset(Dst, 0, Length);                                     // <1>
    }
    __except (ExceptionFilter(GetExceptionCode(), GetExceptionInformation(), &ExceptionDataAddress))
    {
        if (0 != Status)
        {
            PInformation = 0;
            if (0 != ExceptionDataAddress)
            {
                Information = (UINT64)(ExceptionDataAddress - (UINT_PTR)RawDisk->Pointer) /
                    RawDisk->BlockLength;                               // <2>
                PInformation = &Information;
            }

            SpdStorageUnitStatusSetSense(Status,
                SCSI_SENSE_MEDIUM_ERROR, ASC, PInformation);            // <3>
        }
    }
}
----
<1> The actual memory copy or set operation that needs to be protected from any file mapping I/O errors. (These errors should be non-existent in practice, except if the underlying file system is on a bad medium.)
<2> `Information` is used to pass information about the actual block address that caused the I/O error. 
<3> `SpdStorageUnitStatusSetSense` is used to report a SCSI error to the operating system.

`FlushInternal` is used by the `Read`, `Write` and `Flush` storage operations to actually flush the backing storage file.

.`*FlushInternal*`
[source,c]
----
static BOOLEAN FlushInternal(SPD_STORAGE_UNIT *StorageUnit,
    UINT64 BlockAddress, UINT32 BlockCount,
    SPD_STORAGE_UNIT_STATUS *Status)
{
    RAWDISK *RawDisk = StorageUnit->UserContext;
    PVOID FileBuffer = (PUINT8)RawDisk->Pointer + BlockAddress * RawDisk->BlockLength;

    if (!FlushViewOfFile(FileBuffer, BlockCount * RawDisk->BlockLength))
        goto error;
    if (!FlushFileBuffers(RawDisk->Handle))
        goto error;

    return TRUE;

error:
    SpdStorageUnitStatusSetSense(Status,
        SCSI_SENSE_MEDIUM_ERROR, SCSI_ADSENSE_WRITE_ERROR, 0);

    return TRUE;
}
----

== THRESHOLD

== Testing the file system

We now have a functional file system. It supports the following Windows file system functionality:

- Query volume information.
- Open, create, close, delete, rename files and directories.
- Query and set file and directory information.
- Query and set security information (ACL's).
- Read and write files.
- Memory mapped I/O.
- Directory change notifications.
- Lock and unlock files.
- Opportunistic locks.

[NOTE]
====
There is some additional functionality which WinFsp supports but our file system does not implement:

- Open, create, close, delete, query named streams.
- Reparse points and symbolic links.
====

The question is: how can we develop the confidence that our file system works as a "proper" Windows file system?

WinFsp includes a number of test suites that are used for testing its components and its reference file system MEMFS. The primary test suite is called `winfsp-tests` and is a comprehensive test suite that exercises all aspects of Windows file system functionality that WinFsp supports. `Winfsp-tests` can be run in a special `--external` mode where it can be used to test other WinFsp-based file systems. We will use it in this case to test our passthrough file system.

NOTE: `Winfsp-tests` is not included with the WinFsp installer. In order to use `winfsp-tests` one must first clone the WinFsp repository and build the WinFsp Visual Studio solution. The steps to do so are not included in this tutorial.

`Winfsp-tests` exercises some esoteric aspects of Windows file system functionality, so we do not expect all the tests to pass. For example, our simple file system does not maintain `AllocationSize`; we therefore expect related tests to fail. As another example, the passthrough file system uses normal Windows file API's to implement its functionality, as such some security tests are expected to fail if the file system runs under a normal account.

In order to test our file system we create a drive `Y:` using the command line `passthrough-x64 -p C:\\...\passthrough-x64 -m Y:` and then execute the command.

.`*winfsp-tests run*`
----
Y:\>C:\...\winfsp-tests-x64 --external --resilient --case-insensitive-cmp -create_allocation_test -getfileinfo_name_test -delete_access_test -rename_flipflop_test -rename_mmap_test -reparse* -stream* <1> <2>
[snip irrelevant tests]
create_test............................ OK 0.03s
create_related_test.................... OK 0.00s
create_sd_test......................... OK 0.03s
create_notraverse_test................. OK 0.00s
create_backup_test..................... OK 0.00s
create_restore_test.................... OK 0.00s
create_share_test...................... OK 0.00s
create_curdir_test..................... OK 0.00s
create_namelen_test.................... OK 0.02s
getfileinfo_test....................... OK 0.00s
setfileinfo_test....................... OK 0.01s
delete_test............................ OK 0.00s
delete_pending_test.................... OK 0.00s
delete_mmap_test....................... OK 0.02s
rename_test............................ OK 0.06s
rename_open_test....................... OK 0.00s
rename_caseins_test.................... OK 0.02s
getvolinfo_test........................ OK 0.00s
setvolinfo_test........................ OK 0.00s
getsecurity_test....................... OK 0.00s
setsecurity_test....................... OK 0.01s
rdwr_noncached_test.................... OK 0.02s
rdwr_noncached_overlapped_test......... OK 0.03s
rdwr_cached_test....................... OK 0.02s
rdwr_cached_append_test................ OK 0.01s
rdwr_cached_overlapped_test............ OK 0.03s
rdwr_writethru_test.................... OK 0.06s
rdwr_writethru_append_test............. OK 0.01s
rdwr_writethru_overlapped_test......... OK 0.00s
rdwr_mmap_test......................... OK 0.23s
rdwr_mixed_test........................ OK 0.03s
flush_test............................. OK 0.06s
flush_volume_test...................... OK 0.00s
lock_noncached_test.................... OK 0.02s
lock_noncached_overlapped_test......... OK 0.02s
lock_cached_test....................... OK 0.05s
lock_cached_overlapped_test............ OK 0.02s
querydir_test.......................... OK 0.39s
querydir_expire_cache_test............. OK 0.00s
querydir_buffer_overflow_test.......... OK 0.00s
dirnotify_test......................... OK 1.01s
--- COMPLETE ---
----
<1> Run `winfsp-tests` with `--external`, `--resilient` switches which instructs it to run its external file system tests.
<2> Disable tests that are not expected to pass because they test functionality that either we did not implement (`-reparse*`, `-stream*`) or is esoteric (`-create_allocation_test`, `-getfileinfo_name_test`, `-rename_flipflop_test`, `-rename_mmap_test`) or requires that the file system is run under an account with sufficient security rights (`-delete_access_test`).

== Running the file system as a service

Our final task is to discuss how to convert our file system into a service that can be managed by the WinFsp launcher. This allows our file system to provide file services to all processes in the system.

An important thing to consider is that our file system will be running in the SYSTEM account security context, which is different from the security context of any processes that want to use this file system. Recall that the passthrough file system is a simple layer over an underlying file system, therefore how the underlying file system handles security becomes important, particularly when the underlying file system is NTFS.

For this reason we modify the passthrough file system to enable the "backup" and "restore" privileges which are available to a process running under the SYSTEM account. Enabling these privileges allows us to circumvent some NTFS access checks and simply use NTFS as a storage medium. With the `EnableBackupRestorePrivileges` implementation in place all that remains is to call it from `SvcStart`.

.`*EnableBackupRestorePrivileges*`
[source,c]
----
static NTSTATUS EnableBackupRestorePrivileges(VOID)
{
    union
    {
        TOKEN_PRIVILEGES P;
        UINT8 B[sizeof(TOKEN_PRIVILEGES) + sizeof(LUID_AND_ATTRIBUTES)];
    } Privileges;
    HANDLE Token;

    Privileges.P.PrivilegeCount = 2;
    Privileges.P.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
    Privileges.P.Privileges[1].Attributes = SE_PRIVILEGE_ENABLED;

    if (!LookupPrivilegeValueW(0, SE_BACKUP_NAME, &Privileges.P.Privileges[0].Luid) ||
        !LookupPrivilegeValueW(0, SE_RESTORE_NAME, &Privileges.P.Privileges[1].Luid))
        return FspNtStatusFromWin32(GetLastError());

    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &Token))
        return FspNtStatusFromWin32(GetLastError());

    if (!AdjustTokenPrivileges(Token, FALSE, &Privileges.P, 0, 0, 0))
    {
        CloseHandle(Token);

        return FspNtStatusFromWin32(GetLastError());
    }

    CloseHandle(Token);

    return STATUS_SUCCESS;
}
----

We are now ready to register our file system to be managed by the WinFsp launcher. For this purpose we will use the `fsreg.bat` utility which can be found in the WinFsp `bin` directory. `Fsreg.bat` will create all necessary entries in the Windows registry.

From an administrator prompt switch to the passthrough directory and run:

.`*fsreg.bat invocation*`
----
fsreg.bat passthrough build\Debug\passthrough-x64.exe "-u %1 -m %2" "D:P(A;;RPWPLC;;;WD)"
----

With this step complete we can now launch our file system from any command prompt.

image::WinFsp-Tutorial/NetUse.png[First Run]

Alternatively one can use the Windows explorer.

image::WinFsp-Tutorial/Explorer.png[First Run]

== Conclusion

In less than 1000 lines of C code we have written a Windows file system. Our file system implements all commonly used file functionality on Windows. It integrates fully with the OS and has been tested to give us reasonable confidence that it works as expected under many scenarios.

Time to go on and create your own file system! Some ideas for quick gratification:

- *RegFs*: Create a file system view of the registry. Bonus points if you make it read/write and if you find creative ways of handling different registry value types.
- *WinObjFs*: Are you familiar with WinObj from SysInternals? It's a fantastic app to explore the NTOS object namespace. Create a file system that presents this namespace as a file system. *Make it read-only!*
- *ProcFs*: Create something akin to procfs for Windows.
